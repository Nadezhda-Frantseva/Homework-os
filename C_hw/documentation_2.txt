Първо проверявам дали подадените аргументи са 3 на брой. После проверяваме първият аргумент дали е record или replay. Ако е record:
Отваряме файла, подаден като втори аргумент, с помощта на файловия дескриптор fd1. Четем байтовете като ги записваме в променливи както следва:
uint16_t messageType = тип на съобщението: 0x0001 или 0x0002;
uint16_t slots =  16-битово цяло число без знак, показващо активните слотове за филийки; превръщаме го в двоично, с цикъл от 1 до 16 го обхождаме;
uint32_t temperature = температура, обработваме го да е в градуси, присвояваме го на float decimalTemperature;
uint8_t slotID = идентификатор на слот, число между 0 и 15;
char text[13] = текст, низ от 13 символа;
За replay променливите са аналогично дефинирани. 
В record данните четем със read(0, &<име_на_променлива>, sizeof(<име_на_променлива>) -> четем от stdin (0);
В record записваме данните със write(fd1, &<име_на_променлива>, read_size_<име_на_променлива>) -> пишем във файла (fd1);
В replay данните четем със read(fd1, &<име_на_променлива>, sizeof(<име_на_променлива>) -> четем от файла (fd1);
В replay записваме данните със write(1, &<име_на_променлива>, read_size_<име_на_променлива>) -> пишем на stdout (1);
За времето използвам 2 функции: 
1) За засичане на текущото време на получаване на съобщението:
   struct timeval start/end;
   gettimeofday(&start/end, NULL);
2) За приспиването в replay, за да симулирам забавянето на record в replay:
   usleep((temp-last_time)*1000);
   където:
   uint32_t temp = прочетен байт от файла, в който държа времето от record;
   last_time = променлива, пазеща последния temp;

Програмата се стартира при написване на make в терминала, след което, за да се тества record:
curl -Ns https://rnd.qtrp.org/toaster | ./main record log
А за да се тества replay:
./main replay log > /dev/null
Желателно е първо да се тества record, а после replay.



